<h1>Anleitung zur Umsetzung eines eigenen Kollektors</h1><h2>Konfigurieren der configuration.json</h2>DIe configuration.json finden Sie im config Ordner. In dieser JSON Datei befinden sich folgende Attribute:<br><li>name (unique) - Dort steht der Name des Kollektors drin. Dieser Name wird nachher auch auf der Webseite angezeigt.</li><li>collectorId (unique) - Dies ist die Id des Kollektors, die zur Unterscheidung der einzelnen Kollektoren auf der Webseite verwendet wird.</li><li>token - Kann anfangs leer bleiben. Dieses Feld wird vom Kollektor selber geschrieben.</li><li>mainApiUrl - Dort muss die URL drinnen stehen, die genutzt, um die Daten zu posten. Diese Daten müssen am Ende in der Hauptanwendung landen. Ist in der Regel "http://devgame:8080/api"</li><li>jwtSecret - Das jwtSecret ist "GamerControlDINGS".</li><h2>Konfigurieren der docker-compose</h2>Hier gilt es zu beachten, dass der Name des Services und der container_name unique sind. Zudem ist es wichtig, dass im Port Eintrag der rechte Port auf 8080 gesetzt bleibt.<br> Sollten Sie den Port der Hauptanwendung ändern, müssen Sie diese Änderung bei jeden Kollektor vornehmen. Je nach Name des Containers und je nach dem, ob Sie Ihre Git bzw. Jira Umgebung o.ä. im gleichen Docker Netzwerk wie die des Kollektors verwenden ändert sich die URL des Webhooks.<br>Sollten Sie den Fall haben, dass z.B. Ihre Git Umgebung und der Kollektor im gleichen Netzwerk angebunden sind, dann ist die URL zum Posten des Webhooks folgende: "http://CONTAINER_NAME:8080/update".<br>Sollten Sie den Fall haben, dass z.B. Ihre Git Umgebung und der Kollektor nicht im gleichen Netzwerk angebunden sind, dann ist die URL zum Posten des Webhooks folgdene: "http://IHREIP:(ports links)/update".<br><h2>Konfigurieren der Metric-Klasse im models Paket</h2>In der Metric Klasse wird die Tabelle in der Datenbank erstellt. In der sechsten Zeile kann der Tabelle dementsprechend auch ein Name vergeben werden. Weiterhin können noch mehr Spalten hinzugefügt werden.<br> Eine Spalte kann mit "@Column (name = "NAMEDERSPALTE") erstellt werden. Da drunter gehört die Definition der dazugehörigen Variable (z.B. Zeile 23 in der Metric-Klasse).<br>Zusätzlich müssen hier Strings hinzugefügt werden, die auch als Key in der Webhook JSON vorkommen.<h2>Erstellung eines Achievements</h2>Am einfachsten ist es dort sich einige bereits definierte Achievements anzugucken und das Prinzip so zu übernehmen.<br>Wichtig ist jedoch, dass jedes Achievement eine eigene Klasse bekommt und auch eine eigene Id, die in Form eines Strings manuell gesetzt werden müssen.<br>Weiterhin muss in die Funktion "getDistinctIssueKeysByUserAndAction" der zu dem Achievement dazugehörige Key der Webhook JSON stehen (wird beim Jira Collector aus dem Metric Modell übernommen).<h2>Parsen des Webhooks</h2>Die API im restcontroller Paket übergibt den String, der anliegt lediglich an den HookHandlerService. Dort müssen Sie nach den Keys suchen, die für Ihre Achievements wichtig sind. <br>Auch in diesem Fall ist es ratsam den Jira Kollektor als Beispiel zu benutzen. Je nach Key brauchen Sie verschiedene Cases und verschiedene Funktionen.<br>Ihre Funktionen müssen am Ende immer insertMetric mit den entsprechenden Strings, die zu den möglichen Achievements dazugehören aufrufen, um die neuen Werte auch in die richtige Spalte zu schreiben.